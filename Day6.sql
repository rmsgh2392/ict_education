SELECT EMP_ID, ROLE_NAME, START_DATE
FROM EMPLOYEE RIGHT JOIN ROLE_HISTORY
USING(EMP_ID);
--급여 내림차순, 이름 오름차순
SELECT EMP_NAME 이름, SALARY 급여
FROM EMPLOYEE
WHERE DEPT_ID LIKE '50'
OR DEPT_ID IS NULL
ORDER BY 2 DESC, 1;
--2004년 1월 1일 이후 입사한 직원 조회
SELECT EMP_NAME 이름, HIRE_DATE 입사일, 
        DEPT_ID 부서코드, SALARY 급여
FROM  EMPLOYEE
WHERE HIRE_DATE > TO_DATE('20040101', 'RRRRMMDD')
ORDER BY 부서코드 DESC NULLS LAST, 2, 이름;

--부서별 급여 합계 조회
SELECT DEPT_ID, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID
ORDER BY 1 NULLS LAST;

SELECT JOB_ID, SUM(SALARY) 급여합계,
        ROUND(AVG(SALARY), -4) 급여평균,
        COUNT(*)
FROM EMPLOYEE
GROUP BY JOB_ID
ORDER BY JOB_ID NULLS LAST;

SELECT DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '여') 성별,
        SUM(SALARY) "성별별 급여합계",
        ROUND(AVG(SALARY), -4) "성별별 급여평균",
        COUNT(*) 직원수
FROM EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '여');


SELECT DEPT_ID, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_ID
ORDER BY 1;

SELECT DEPT_ID, COUNT(DECODE(MARRIAGE, 'Y', 1))
FROM EMPLOYEE
GROUP BY DEPT_ID, DECODE(MARRIAGE, 'Y', 1)
ORDER BY 1;

-- 부서별 급여합계중 가장 큰값에 대한 부서코드와 급여합계 조회
SELECT DEPT_ID 부서별,
        SUM(SALARY) 부서별급여합계
FROM EMPLOYEE
GROUP BY DEPT_ID
--HAVING SUM(SALARY) LIKE 18100000;
--서브쿼리 사용 예
--서브쿼리가 먼저 실행되고 나온 값을 비교할 값으로 표시해 비교
HAVING SUM(SALARY) LIKE (SELECT MAX(SUM(SALARY)) FROM EMPLOYEE GROUP BY DEPT_ID); 
--비교값 자리에는 함수식 사용을 못하고 값을 명시적으로 써줘야한다.
--SUM(SALARY) = MAX(SUM(SALARY)) --ERROR: 서브쿼리 사용

--부서별 급여합계 9백만 초과 하는 부서와 급여합계 조회
SELECT DEPT_ID, SUM(SALARY), JOB_ID
FROM EMPLOYEE
GROUP BY DEPT_ID, JOB_ID
HAVING SUM(SALARY) > 9000000;

--급여를 많이 받는 순으로 순위를 매긴다면??
SELECT EMP_NAME, SALARY,
        RANK() OVER (ORDER BY SALARY DESC) 순위
FROM EMPLOYEE
ORDER BY 순위;

--급여 350만원이 내림차순 정렬 했을 때 전체 급여중 몇 순위??
SELECT RANK(3500000) WITHIN GROUP(ORDER BY SALARY DESC) 순위
FROM EMPLOYEE;

--ROLLUP 함수
SELECT DEPT_ID, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID;

SELECT DEPT_ID, SUM(SALARY), MAX(SALARY)부서별가장큰급여, MIN(SALARY)부서별가장작은급여,
        ROUND(AVG(SALARY), -4)부서별평균급여
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID);

--부서코드와 직급코드를 함계 그룹을 묶고 급여의 합계를 구함
--ROLLUP사용, NULL칸 제외
SELECT DEPT_ID, JOB_ID, SUM(SALARY)급여합계
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID, JOB_ID);
--총 집계가 중간이나 끝에 쓰고 싶은 경우 ROLLUP함수 사용
SELECT DEPT_ID, JOB_ID, SUM(SALARY)급여합계
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID), ROLLUP(JOB_ID);
-----------------------------------------
SELECT DEPT_ID, JOB_ID, SUM(SALARY)급여합계
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID), ROLLUP(DEPT_ID);

SELECT DEPT_ID, JOB_ID, SUM(SALARY)급여합계
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
AND JOB_ID IS NOT NULL
GROUP BY CUBE(DEPT_ID, JOB_ID); --총 집계가 가장 위로 올라가는 경우가 CUBE함수

SELECT EMP_ID, ROWID
FROM EMPLOYEE;

--================================
SELECT EMP_NAME, DEPT_NAME, DEPT_ID
FROM EMPLOYEE RIGHT JOIN DEPARTMENT
USING(DEPT_ID);

--오라클 전용구문 : 오라클에서만 사용-------------------------
SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.DEPT_ID LIKE DEPARTMENT.DEPT_ID;

SELECT E.EMP_NAME, D.DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID LIKE D.DEPT_ID;
--EMPLOYEE에 DEPT_ID에 NULL값과 DEPARTMENT DEPT_ID에 일치하는 값이 없어
--조인에서 제외

--ANSI표준 구문------------------------------------------------
SELECT *
FROM EMPLOYEE JOIN DEPARTMENT
USING(DEPT_ID);

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM EMPLOYEE JOIN DEPARTMENT
USING(DEPT_ID);

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM EMPLOYEE LEFT JOIN DEPARTMENT
USING(DEPT_ID)

SELECT D.DEPT_ID, D.DEPT_NAME, D.LOC_ID, R.LOC_DESCRIBE
FROM DEPARTMENT D, LOCATION R
WHERE D.LOC_ID LIKE R.LOCATION_ID;

SELECT D.DEPT_ID, D.DEPT_NAME, D.LOC_ID, L.LOC_DESCRIBE
FROM DEPARTMENT D JOIN LOCATION L
ON D.LOC_ID LIKE L.LOCATION_ID;

SELECT E.EMP_NAME, D.DEPT_NAME, L.LOCATION_ID, L.LOC_DESCRIBE
FROM EMPLOYEE E, DEPARTMENT D, LOCATION L
WHERE E.DEPT_ID LIKE D.DEPT_ID AND D.LOC_ID LIKE L.LOCATION_ID;

SELECT EMP_NAME, LOC_ID
FROM EMPLOYEE2 JOIN DEPARTMENT
USING(DEPT_ID, LOC_ID);


--사번, 이름, 직급명 조회
SELECT EMP_ID 사번, EMP_NAME 이름, JOB_TITLE 직급명
FROM EMPLOYEE JOIN JOB 
USING(JOB_ID); --ANSI표준 USING()

SELECT E.EMP_ID, E.EMP_NAME, J.JOB_TITLE
FROM EMPLOYEE E JOIN JOB J
ON E.JOB_ID LIKE J.JOB_ID; --ANSI표준 ON 

SELECT E.EMP_ID, E.EMP_NAME, E.JOB_TITLE
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID LIKE J.JOB_ID; --ORACLE표준

--OUTER JOIN 오라클 전용구문
SELECT *
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID LIKE D.DEPT_ID(+);

--OUTER JOIN ANSI 표준구문
SELECT * 
FROM EMPLOYEE LEFT JOIN DEPARTMENT
USING(DEPT_ID);

SELECT *
FROM EMPLOYEE RIGHT JOIN DEPARTMENT
USING(DEPT_ID);

-- 두 테이블의 일치하지 않는 행을 모두 조인에 포함시키고자 할 경우
-- ANSI표준
SELECT * 
FROM EMPLOYEE FULL /*OUTER*/ JOIN DEPARTMENT
USING(DEPT_ID);

--CROSS JOIN 
-- ANSI 표준구문
SELECT *
FROM LOCATION CROSS JOIN COUNTRY;

--ORACLE 전용 구문
SELECT * 
FROM LOCATION, COUNTRY;

--NON EQUAL JOIN
--직원들의 급여에 대한 급여 등급을 매기고자 할 경우
SELECT *
FROM EMPLOYEE JOIN SAL_GRADE 
ON (SALARY BETWEEN LOWEST AND HIGHEST);

--SELF JOIN
--같은 테이블을 두번 조인하는 경우
--같은 테이블 안의 다른 컬럼을 외래키로 참조하고 있는 경우에 사용가능
--ANSI표준
SELECT E.EMP_NAME 직원,
        M.EMP_NAME 관리자
FROM EMPLOYEE E JOIN EMPLOYEE M
ON(E.MGR_ID LIKE M.EMP_ID);

--ORACLE 구문
SELECT * 
FROM EMPLOYEE E, EMPLOYEE M
WHERE E.MGR_ID LIKE M.EMP_ID;

--다중 N개의 JOIN 
--JOIN하는 순서가 중요하다 !!
SELECT EMP_NAME, DEPT_NAME, JOB_TITLE, LOC_DESCRIBE
FROM EMPLOYEE JOIN JOB 
USING(JOB_ID)
JOIN DEPARTMENT USING(DEPT_ID)
JOIN LOCATION ON (LOC_ID LIKE LOCATION_ID);


--=======================================================================
-- JOIN 연습문제

-- 1. 2020년 12월 25일이 무슨 요일인지 조회하시오.
    SELECT TO_CHAR(TO_DATE('20201225', 'YYYYMMDD'), 'DAY')
    FROM DUAL;


-- 2. 주민번호가 60년대 생이면서 성별이 여자이고, 
-- 성이 김씨인 직원들의 
-- 사원명, 주민번호, 부서명, 직급명을 조회하시오.
   SELECT TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') || '년대' 생년,
           DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') 성별,
           EMP_NAME 사원명, EMP_NO 주민번호, 
           DEPT_NAME 부서명, JOB_TITLE 직급명
   FROM EMPLOYEE JOIN 
   DEPARTMENT USING(DEPT_ID) 
   JOIN JOB USING(JOB_ID)
   GROUP BY TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY'), 
              DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여'),
            EMP_NAME, EMP_NO, DEPT_NAME, JOB_TITLE
   HAVING TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') LIKE '6%'
   AND DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') LIKE '여'
   AND EMP_NAME LIKE '김%'; --ANSI
   
   SELECT TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') || '년대' 생년,
           DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') 성별,
           EMP_NAME 사원명, EMP_NO 주민번호, 
           DEPT_NAME 부서명, JOB_TITLE 직급명
   FROM EMPLOYEE E, DEPARTMENT D, JOB J
   WHERE E.DEPT_ID LIKE D.DEPT_ID
   AND E.JOB_ID LIKE J.JOB_ID
   GROUP BY TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY'),
           DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여'),
           EMP_NAME, EMP_NO, DEPT_NAME , JOB_TITLE 
   HAVING TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') LIKE '6%'
   AND DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') LIKE '여'
   AND EMP_NAME LIKE '김%'; --ORACLE
   
   
   
   
    SELECT  TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') 년생,
           DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') 성별,
           EMP_NAME 사원명, EMP_NO 주민번호,
           DEPT_NAME 부서명, JOB_TITLE 직급명
   FROM EMPLOYEE LEFT JOIN DEPARTMENT USING(DEPT_ID)
   LEFT JOIN JOB USING(JOB_ID)
   WHERE TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') LIKE '6%'
   --WHERE SUBSTR(EMP_NO, 1, 2) LIKE '6%'
   AND DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') LIKE '여'
   -- SUBSTR(EMP_NO, 8, 1) IN ('2', '4')
   AND EMP_NAME LIKE '김%'; --ANSI
   
   SELECT TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') 년생,
           DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') 성별,
           EMP_NAME 사원명, EMP_NO 주민번호,
           DEPT_NAME 부서명, JOB_TITLE 직급명
   FROM EMPLOYEE E, DEPARTMENT D, JOB J
   WHERE E.DEPT_ID LIKE D.DEPT_ID(+)
   AND E.JOB_ID LIKE J.JOB_ID(+)
   AND TO_CHAR(TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR'), 'YY') LIKE '6%'
   AND DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '3', '남', '여') LIKE '여'
   AND EMP_NAME LIKE '김%'; -- ORACLE
   


-- 3. 가장 나이가 적은 직원의 
-- 사번, 사원명, 나이, 부서명, 직급명을 조회하시오.
   SELECT EMP_ID 사번, EMP_NAME 사원명, 
           MIN(TO_NUMBER(EXTRACT(YEAR FROM SYSDATE) - 
                         EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')))) 나이,
           DEPT_NAME 부서명, JOB_TITLE 직급명
   FROM EMPLOYEE LEFT JOIN DEPARTMENT USING(DEPT_ID)
   LEFT JOIN JOB USING(JOB_ID)
   GROUP BY EMP_ID, EMP_NAME, DEPT_NAME, JOB_TITLE
   HAVING MIN(TO_NUMBER(EXTRACT(YEAR FROM SYSDATE) - 
                     EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')))) 
                     LIKE (SELECT MIN(TO_NUMBER(EXTRACT(YEAR FROM SYSDATE) - 
                                                EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')))) 
                                                FROM EMPLOYEE);
                                              
    SELECT EMP_ID, EMP_NAME, 
            MIN(TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')) /12 )) 나이,
            DEPT_NAME, JOB_TITLE
    FROM EMPLOYEE LEFT JOIN JOB USING(JOB_ID)
    LEFT JOIN DEPARTMENT USING(DEPT_ID)
    GROUP BY EMP_ID, EMP_NAME, DEPT_NAME, JOB_TITLE
    HAVING  MIN(TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')) /12 )) LIKE 31;
    
    SELECT EMP_ID, EMP_NAME, 
            MIN(TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')) /12 )) 나이,
            DEPT_NAME, JOB_TITLE
    FROM EMPLOYEE E, JOB J, DEPARTMENT D
    WHERE E.JOB_ID LIKE J.JOB_ID(+)
    AND E.DEPT_ID LIKE D.DEPT_ID(+)
    GROUP BY EMP_ID, EMP_NAME, DEPT_NAME, JOB_TITLE
    HAVING  MIN(TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')) /12 )) LIKE 31;
   
-- 나이의 최소값 조회
   SELECT MIN(TO_NUMBER(EXTRACT(YEAR FROM SYSDATE) 
             - EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM'))))
   FROM EMPLOYEE;   
   
   SELECT MIN(TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE(SUBSTR(EMP_NO, 1, 4), 'RRMM')) /12 ))
   FROM EMPLOYEE;

-- 조회한 나이의 최소값을 이용해 직원의 정보 조회함
-- outer join 필요함.



-- 4. 이름에 '성'자가 들어가는 직원들의 
-- 사번, 사원명, 부서명을 조회하시오.
    SELECT EMP_ID 사번, EMP_NAME 사원명,
            DEPT_NAME 부서명
    FROM EMPLOYEE LEFT JOIN DEPARTMENT
    USING(DEPT_ID)
    WHERE EMP_NAME LIKE '%성%'; --ANSI
    
    SELECT EMP_ID 사번, EMP_NAME 사원명,
            DEPT_NAME 부서명
    FROM EMPLOYEE E, DEPARTMENT D
    WHERE E.DEPT_ID LIKE D.DEPT_ID(+)
    AND EMP_NAME LIKE '%성%'; --ORACLE


-- 5. 해외영업팀에 근무하는 
-- 사원명, 직급명, 부서코드, 부서명을 조회하시오.
--부서는 있는데 직급이 이슨 직원이 있을수 있고 
--직급은 있는데 부서가 없을 수도 있으니까 전체 직원을 가지고 조회해야하니까 OUTER JOIN 사용
    SELECT EMP_NAME 사원명, JOB_TITLE 직급명, 
            DEPT_ID 부서코드, DEPT_NAME 부서명
    FROM EMPLOYEE LEFT JOIN DEPARTMENT
    USING(DEPT_ID)
    LEFT JOIN JOB USING(JOB_ID)
    WHERE DEPT_NAME LIKE '해외%'
    ORDER BY 4; --ANSI
    
    SELECT E.EMP_NAME 사원명, J.JOB_TITLE 직급명, 
            D.DEPT_ID 부서코드, D.DEPT_NAME 부서명
    FROM EMPLOYEE E, DEPARTMENT D, JOB J
    WHERE E.DEPT_ID LIKE D.DEPT_ID(+) 
    AND E.JOB_ID LIKE J.JOB_ID(+)
    AND DEPT_NAME LIKE '해외%'
    ORDER BY 4; --ORACLE


-- 6. 보너스포인트를 받는 직원들의 
-- 사원명, 보너스포인트, 부서명, 근무지역명을 조회하시오.
    SELECT EMP_NAME 사원명, BONUS_PCT 보너스포인트,
            DEPT_NAME 부서명, LOC_DESCRIBE 근무지역
    FROM EMPLOYEE LEFT JOIN DEPARTMENT 
                USING(DEPT_ID)
    LEFT JOIN LOCATION ON 
                (LOC_ID LIKE LOCATION_ID)
    WHERE BONUS_PCT IS NOT NULL 
    OR BONUS_PCT NOT LIKE 0.0
    ORDER BY 2; --ANSI
    
    SELECT E.EMP_NAME 사원명, E.BONUS_PCT 보너스포인트,
            D.DEPT_NAME 부서명, L.LOC_DESCRIBE 근무지역
    FROM EMPLOYEE E, DEPARTMENT D, LOCATION L
    WHERE E.DEPT_ID LIKE D.DEPT_ID(+)
    AND D.LOC_ID LIKE L.LOCATION_ID(+)
    AND (E.BONUS_PCT IS NOT NULL OR BONUS_PCT NOT LIKE 0.0)
    --연산자중에 OR보다 AND연산자가 우선순위가 높다.
    ORDER BY 2; --ORACLE

-- 7. 부서코드가 20인 직원들의 
-- 사원명, 직급명, 부서명, 근무지역명을 조회하시오.
    SELECT EMP_NAME, JOB_TITLE, DEPT_ID, DEPT_NAME, LOC_DESCRIBE
    FROM EMPLOYEE LEFT JOIN JOB USING(JOB_ID)
    LEFT JOIN DEPARTMENT USING(DEPT_ID)
    LEFT JOIN LOCATION ON (LOC_ID LIKE LOCATION_ID)
    WHERE DEPT_ID LIKE '20';--ANSI
    
    SELECT E.EMP_NAME 사원명, J.JOB_TITLE 직급명, 
            D.DEPT_NAME 부서명, L.LOC_DESCRIBE 근무지역명
    FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
    WHERE E.JOB_ID LIKE J.JOB_ID(+)
    AND E.DEPT_ID LIKE D.DEPT_ID(+)
    AND D.LOC_ID LIKE L.LOCATION_ID(+)
    AND D.DEPT_ID LIKE '20'; --ORACLE


-- 8. 직급별 연봉의 최소급여(MIN_SAL)보다 많이 받는 직원들의
-- 사원명, 직급명, 급여, 연봉을 조회하시오.
-- 연봉은 보너스포인트를 적용하시오.
    SELECT EMP_NAME 사원명, JOB_TITLE 직급명, 
            SALARY 급여, (SALARY + (SALARY * NVL(BONUS_PCT, 0))) * 12 연봉
    FROM EMPLOYEE LEFT JOIN 
          JOB USING(JOB_ID)
    WHERE (SALARY + (SALARY * NVL(BONUS_PCT, 0))) * 12  > MIN_SAL; --ANSI
    
    SELECT EMP_NAME, JOB_TITLE, SALARY, (SALARY + (SALARY * NVL(BONUS_PCT, 0))) * 12 연봉
    FROM EMPLOYEE E, JOB J
    WHERE E.JOB_ID LIKE J.JOB_ID
    AND (SALARY + (SALARY * NVL(BONUS_PCT, 0))) * 12  > J.MIN_SAL;

--===============================================
   

-- 9 . 한국(KO)과 일본(JP)에 근무하는 직원들의 
-- 사원명(emp_name), 부서명(dept_name), 지역명(loc_describe),
--  국가명(country_name)을 조회하시오.
    SELECT EMP_NAME 사원명, DEPT_NAME 부서명,
            LOC_DESCRIBE 지역명, COUNTRY_NAME 국가명
    FROM EMPLOYEE JOIN DEPARTMENT USING(DEPT_ID)
    JOIN LOCATION ON (LOC_ID LIKE LOCATION_ID)
    JOIN COUNTRY USING(COUNTRY_ID)
    WHERE COUNTRY_ID IN ('KO', 'JP'); --ANSI 
    
    SELECT E.EMP_NAME 사원명, D.DEPT_NAME 부서명,
            L.LOC_DESCRIBE 지역명, C.COUNTRY_NAME 국가명
    FROM EMPLOYEE E, DEPARTMENT D, LOCATION L, COUNTRY C
    WHERE E.DEPT_ID LIKE D.DEPT_ID
    AND D.LOC_ID LIKE L.LOCATION_ID
    AND L.COUNTRY_ID LIKE C.COUNTRY_ID
    AND C.COUNTRY_ID IN('KO', 'JP'); --ORACLE
    
    
 

-- 10. 같은 부서에 근무하는 직원들의 
-- 사원명, 부서코드, 동료이름, 부서코드를 조회하시오.
-- self join 사용
    SELECT  E.EMP_NAME 사원명,  E.DEPT_ID 부서코드,
             M.EMP_NAME 동료이름,   M.DEPT_ID 부서코드
    FROM EMPLOYEE E JOIN EMPLOYEE M
    ON E.DEPT_ID LIKE M.DEPT_ID
    WHERE E.EMP_NAME NOT LIKE M.EMP_NAME
    -- ON (E.EMP_NAME NOT LOKE M.EMP_NAME AND E.DEPT_ID LIKE D.DEPT_ID)
    -- ON은 조건이니까 한번에 조건들을 써도된다.
    ORDER BY E.EMP_NAME; --ANSI
    
    SELECT E.EMP_NAME 사원명, E.DEPT_ID 부서코드,
            M.EMP_NAME 동료이름, M.DEPT_ID 부서코드
    FROM EMPLOYEE E, EMPLOYEE M
    WHERE E.DEPT_ID LIKE M.DEPT_ID
    AND E.EMP_NAME != M.EMP_NAME; -- ORACLE



-- 11. 보너스포인트가 없는 직원들 중에서 
-- 직급코드가 J4와 J7인 직원들의 사원명, 직급명, 급여를 조회하시오.
   SELECT EMP_NAME 사원명, JOB_TITLE 직급명, SALARY 급여
   FROM EMPLOYEE LEFT JOIN JOB
   USING(JOB_ID)
   WHERE JOB_ID IN('J4', 'J7')
   AND (BONUS_PCT IS NULL OR BONUS_PCT LIKE 0.0); --ANSI

   SELECT EMP_NAME 사원명, JOB_TITLE 직급명, SALARY 급여
   FROM EMPLOYEE E, JOB J
   WHERE E.JOB_ID LIKE J.JOB_ID(+)
   AND (BONUS_PCT IS NULL OR BONUS_PCT LIKE 0.0)
   AND E.JOB_ID IN ('J4', 'J7');--ORACLE

-- 12. 소속부서가 50 또는 90인 직원중 
-- 기혼인 직원과 미혼인 직원의 수를 조회하시오.
    SELECT DECODE(MARRIAGE, 'Y', '기혼', 'N', '미혼') 결혼여부,
            COUNT(*)
    FROM EMPLOYEE
    WHERE DEPT_ID IN ('50', '90')
    GROUP BY DECODE(MARRIAGE, 'Y', '기혼', 'N', '미혼');
   